<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>Navratri Photo Frame</title>
    <style>
      body {
        margin: 0;
        padding: 0;
        min-height: 100vh;
        background-color: #a05aff;
        background-repeat: repeat; /* repeat in both directions */
        background-size: auto; /* use original image size */
        background-attachment: fixed;
        background-position: 0 0;
      }
      .camera-wrapper {
        position: relative;
        max-width: 400px; /* match your camera-container size */
        margin: 0 auto; /* center the wrapper itself on the page */
      }
      .camera-container {
        position: relative;
        display: inline-block;
        width: 100%;
        max-width: 400px; /* adjust as needed */
        aspect-ratio: 9 / 16; /* default to portrait; will be updated to frame ratio */
        border: 2px solid #ccc;
        border-radius: 10px;
        overflow: hidden;
      }
      /* Buttons container - center aligned */
      .action-buttons {
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 20px; /* spacing between elements */
        margin: 20px auto 0 auto;
      }

      /* Button row for horizontal layout */
      .button-row {
        display: flex;
        justify-content: center;
        align-items: center;
        gap: 20px; /* spacing between capture and download buttons */
      }

      video {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        object-fit: cover; /* fill portrait area without stretching */
        z-index: 0; /* below captured photo */
      }

      /* Flip video horizontally for front camera (mirror effect) */
      video.front-camera {
        transform: scaleX(-1);
        -webkit-transform: scaleX(-1);
        -moz-transform: scaleX(-1);
        -ms-transform: scaleX(-1);
      }

      /* Flip captured photo horizontally for front camera (mirror effect) */
      #capturedPhoto.front-camera {
        transform: scaleX(-1);
        -webkit-transform: scaleX(-1);
        -moz-transform: scaleX(-1);
        -ms-transform: scaleX(-1);
      }

      /* Overlay frame */
      #frame {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        pointer-events: none; /* allow clicks through */
        object-fit: cover;
        z-index: 2; /* above captured photo */
      }

      #canvas {
        display: none;
      }

      /* Captured photo overlay inside camera frame */
      #capturedPhoto {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        object-fit: cover; /* Same as video - fill the container */
        display: none;
        z-index: 1; /* above video but below frame */
        border-radius: 10px; /* match camera container border radius */
        pointer-events: none; /* prevent any interaction */
        transform: none; /* ensure no transforms */
        transition: none; /* no animations */
        animation: none; /* no animations */
      }

      button {
        margin-top: 10px;
        padding: 10px 20px;
        font-size: 16px;
        cursor: pointer;
        border: 5px solid #006eff; /* Azure border */
        background-color: #ffffff; /* white fill */
        color: #006eff; /* Azure text */
        font-family: "Trois Mille 19 Regular";
      }

      /* Flip camera button overlay */
      #flipBtn {
        position: absolute;
        top: 30px;
        right: 40px;
        width: 64px;
        height: 64px;
        border: none;
        border-radius: 50%;
        background: rgba(0, 0, 0, 0.5);
        color: #fff;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 20px;
        line-height: 1;
        cursor: pointer;
        z-index: 2;
      }
      /* Common button styles */
      .btn {
        display: inline-block;
        width: 200px; /* adjust size as needed */
        height: 60px;
        background-size: contain;
        background-position: center;
        background-repeat: no-repeat;
        cursor: pointer;
        border: none;
        text-decoration: none;
        flex-shrink: 0; /* prevent buttons from shrinking */
      }

      /* Capture button background */
      .capture-btn {
        background-image: url("{{ url_for('static', filename='Capture.png') }}");
        transition: none;
        animation: none;
      }

      /* Download button background */
      .download-btn {
        background-image: url("{{ url_for('static', filename='Download.png') }}");
        transition: none;
        animation: none;
      }
    </style>
  </head>
  <body>
    <!-- Camera + Buttons Wrapper -->
    <div class="camera-wrapper">
      <!-- Camera + Frame Overlay -->
      <div class="camera-container">
        <video id="camera" autoplay playsinline></video>
        <button id="flipBtn" aria-label="Flip camera" title="Flip camera">
          <svg
            width="100%"
            height="100%"
            viewBox="0 0 24 24"
            fill="none"
            stroke="currentColor"
            stroke-width="3"
            stroke-linecap="round"
            stroke-linejoin="round"
            aria-hidden="true"
          >
            <path d="M21 12a9 9 0 1 1-3-6.7" />
            <polyline points="21 3 21 9 15 9" />
          </svg>
        </button>
        <img
          id="frame"
          src="{{ url_for('static', filename='navratri_frame.png') }}"
        />
        <!-- Captured photo overlay -->
        <img id="capturedPhoto" style="display: none" />
      </div>

      <!-- Action Buttons: placed directly below the camera/canvas area -->
      <br />
      <!-- Action Buttons -->
      <br />
      <div class="action-buttons">
        <div class="button-row">
          <a
            id="capture"
            class="btn capture-btn"
            style="display: inline-block"
          ></a>

          <a
            id="downloadBtn"
            class="btn download-btn"
            style="display: none"
            download="navratri_click.png"
          ></a>
        </div>
      </div>
    </div>

    <!-- Hidden Canvas -->
    <canvas id="canvas"></canvas>

    <script>
      const video = document.getElementById("camera");
      const canvas = document.getElementById("canvas");
      const capturedPhoto = document.getElementById("capturedPhoto");
      const button = document.getElementById("capture");
      const frame = document.getElementById("frame");
      const downloadBtn = document.getElementById("downloadBtn");
      const flipBtn = document.getElementById("flipBtn");
      const container = document.querySelector(".camera-container");

      let currentFacingMode = "environment"; // or "user"
      let currentStream = null;

      async function startCamera() {
        try {
          // Stop any existing stream before starting a new one
          if (currentStream) {
            currentStream.getTracks().forEach((t) => t.stop());
            currentStream = null;
          }

          const constraints = { video: { facingMode: currentFacingMode } };
          const stream = await navigator.mediaDevices.getUserMedia(constraints);
          currentStream = stream;
          video.srcObject = stream;

          // Set initial front-camera class for mirror effect
          if (currentFacingMode === "user") {
            video.classList.add("front-camera");
            console.log("Front camera: mirror effect applied");
          } else {
            video.classList.remove("front-camera");
            console.log("Back camera: mirror effect removed");
          }
        } catch (err) {
          alert("Camera not accessible: " + err);
        }
      }

      // Initialize camera on load
      startCamera();

      // Ensure container uses the frame's true aspect ratio for portrait layout
      frame.onload = () => {
        if (frame.naturalWidth && frame.naturalHeight) {
          container.style.aspectRatio = `${frame.naturalWidth} / ${frame.naturalHeight}`;
        }
      };

      // Flip camera handler
      flipBtn.onclick = async () => {
        currentFacingMode =
          currentFacingMode === "environment" ? "user" : "environment";
        await startCamera();

        // Add/remove front-camera class for mirror effect
        if (currentFacingMode === "user") {
          video.classList.add("front-camera");
          // Also update captured photo if it's displayed
          if (capturedPhoto.style.display === "block") {
            capturedPhoto.classList.add("front-camera");
          }
          console.log("Switched to front camera: mirror effect applied");
        } else {
          video.classList.remove("front-camera");
          // Also update captured photo if it's displayed
          if (capturedPhoto.style.display === "block") {
            capturedPhoto.classList.remove("front-camera");
          }
          console.log("Switched to back camera: mirror effect removed");
        }
      };

      // Re-capture function
      function recapturePhoto() {
        // Hide captured photo and show video again
        capturedPhoto.style.display = "none";
        capturedPhoto.classList.remove("front-camera"); // Reset transform
        video.style.display = "block";

        // Show flip camera button again by restoring z-index
        flipBtn.style.zIndex = "2";

        // Hide download button
        downloadBtn.style.display = "none";

        // Reset capture button to original function
        button.onclick = capturePhoto;
      }

      // Capture logic (exports portrait with center-cropped video)
      function capturePhoto() {
        if (video.videoWidth === 0 || video.videoHeight === 0) {
          alert("Video not ready yet, try again.");
          return;
        }

        // Target size exactly matches the visible capture area (canvas) ratio
        const dpr = window.devicePixelRatio || 1;
        const rect = container.getBoundingClientRect();
        const targetWidth = Math.round(rect.width * dpr);
        const targetHeight = Math.round(rect.height * dpr);
        canvas.width = targetWidth;
        canvas.height = targetHeight;
        const ctx = canvas.getContext("2d");

        // Center-crop the video to cover the portrait canvas
        const srcW = video.videoWidth;
        const srcH = video.videoHeight;
        const targetAspect = targetWidth / targetHeight;
        const srcAspect = srcW / srcH;

        let sx = 0;
        let sy = 0;
        let sWidth = srcW;
        let sHeight = srcH;

        if (srcAspect > targetAspect) {
          // Source is wider than target -> crop width
          sWidth = Math.round(srcH * targetAspect);
          sx = Math.round((srcW - sWidth) / 2);
        } else if (srcAspect < targetAspect) {
          // Source is taller than target -> crop height
          sHeight = Math.round(srcW / targetAspect);
          sy = Math.round((srcH - sHeight) / 2);
        }

        ctx.drawImage(
          video,
          sx,
          sy,
          sWidth,
          sHeight,
          0,
          0,
          targetWidth,
          targetHeight
        );

        // Draw overlay frame to exact canvas size
        ctx.drawImage(frame, 0, 0, targetWidth, targetHeight);

        // Create image data
        const dataURL = canvas.toDataURL("image/png");

        // Show captured photo inside the camera frame with exact same positioning as video
        capturedPhoto.src = dataURL;
        capturedPhoto.style.display = "block";

        // Apply the same transform as video if it's front camera
        if (currentFacingMode === "user") {
          capturedPhoto.classList.add("front-camera");
        } else {
          capturedPhoto.classList.remove("front-camera");
        }

        console.log("Captured photo displayed, video hidden");

        // Hide video and show captured photo
        video.style.display = "none";

        // Hide flip camera button behind captured photo by reducing z-index
        flipBtn.style.zIndex = "0";

        // Enable download button
        downloadBtn.href = dataURL;
        downloadBtn.style.display = "inline-block";

        // Change capture button to re-capture
        button.className = "btn capture-btn";
        button.onclick = recapturePhoto;

        // Send to Flask backend
        fetch("/save_photo", {
          method: "POST",
          headers: { "Content-Type": "application/x-www-form-urlencoded" },
          body: "image=" + encodeURIComponent(dataURL),
        })
          .then((res) => res.text())
          .then((msg) => console.log("Server:", msg))
          .catch((err) => console.error("Upload failed:", err));
      }

      // Set initial button onclick
      button.onclick = capturePhoto;
    </script>
  </body>
</html>
