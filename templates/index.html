<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>Navratri Photo Frame</title>
    <style>
      body {
        margin: 0;
        padding: 0;
        background-image: url("memphis-mini.png");
        background-repeat: repeat; /* repeat in both directions */
        background-size: auto; /* use original image size */
      }
      .camera-wrapper {
        position: relative;
        max-width: 400px; /* match your camera-container size */
        margin: 0 auto; /* center the wrapper itself on the page */
      }
      .camera-container {
        position: relative;
        display: inline-block;
        width: 100%;
        max-width: 400px; /* adjust as needed */
        aspect-ratio: 9 / 16; /* default to portrait; will be updated to frame ratio */
        border: 2px solid #ccc;
        border-radius: 10px;
        overflow: hidden;
      }
      /* Buttons container - center aligned */
      .action-buttons {
        width: 200px; /* spacing between capture and download */
        margin: auto;
      }

      video {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        object-fit: cover; /* fill portrait area without stretching */
      }

      /* Overlay frame */
      #frame {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        pointer-events: none; /* allow clicks through */
        object-fit: cover;
      }

      #canvas {
        display: none;
      }

      button {
        margin-top: 10px;
        padding: 10px 20px;
        font-size: 16px;
        cursor: pointer;
        border: 5px solid #006eff; /* Azure border */
        background-color: #ffffff; /* white fill */
        color: #006eff; /* Azure text */
        font-family: "Trois Mille 19 Regular";
      }

      /* Flip camera button overlay */
      #flipBtn {
        position: absolute;
        top: 10px;
        right: 10px;
        width: 64px;
        height: 64px;
        border: none;
        border-radius: 50%;
        background: rgba(0, 0, 0, 0.5);
        color: #fff;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 20px;
        line-height: 1;
        cursor: pointer;
        z-index: 2;
      }
      /* Common button styles */
      .btn {
        display: inline-block;
        width: 200px; /* adjust size as needed */
        height: 60px;
        background-size: cover;
        background-position: center;
        background-repeat: no-repeat;
        cursor: pointer;
        border: none;
        text-decoration: none;
      }

      /* Capture button background */
      .capture-btn {
        background-image: url("{{ url_for('static', filename='Capture.png') }}");
      }

      /* Download button background */
      .download-btn {
        background-image: url("{{ url_for('static', filename='Download.png') }}");
      }
    </style>
  </head>
  <body>
    <!-- Camera + Buttons Wrapper -->
    <div class="camera-wrapper">
      <!-- Camera + Frame Overlay -->
      <div class="camera-container">
        <video id="camera" autoplay playsinline></video>
        <button id="flipBtn" aria-label="Flip camera" title="Flip camera">
          <svg
            width="100%"
            height="100%"
            viewBox="0 0 24 24"
            fill="none"
            stroke="currentColor"
            stroke-width="3"
            stroke-linecap="round"
            stroke-linejoin="round"
            aria-hidden="true"
          >
            <path d="M21 12a9 9 0 1 1-3-6.7" />
            <polyline points="21 3 21 9 15 9" />
          </svg>
        </button>
        <img
          id="frame"
          src="{{ url_for('static', filename='navratri_frame.png') }}"
        />
      </div>

      <!-- Action Buttons: placed directly below the camera/canvas area -->
      <br />
      <!-- Action Buttons -->
      <br />
      <div class="action-buttons">
        <a
          id="capture"
          class="btn capture-btn"
          style="display: inline-block"
        ></a>

        <a id="downloadBtn" class="btn download-btn" style="display: none"></a>
      </div>
    </div>

    <!-- Hidden Canvas -->
    <canvas id="canvas"></canvas>

    <!-- Preview Output -->
    <img id="output" style="display: none" />

    <script>
      const video = document.getElementById("camera");
      const canvas = document.getElementById("canvas");
      const output = document.getElementById("output");
      const button = document.getElementById("capture");
      const frame = document.getElementById("frame");
      const downloadBtn = document.getElementById("downloadBtn");
      const flipBtn = document.getElementById("flipBtn");
      const container = document.querySelector(".camera-container");

      let currentFacingMode = "environment"; // or "user"
      let currentStream = null;

      async function startCamera() {
        try {
          // Stop any existing stream before starting a new one
          if (currentStream) {
            currentStream.getTracks().forEach((t) => t.stop());
            currentStream = null;
          }

          const constraints = { video: { facingMode: currentFacingMode } };
          const stream = await navigator.mediaDevices.getUserMedia(constraints);
          currentStream = stream;
          video.srcObject = stream;
        } catch (err) {
          alert("Camera not accessible: " + err);
        }
      }

      // Initialize camera on load
      startCamera();

      // Ensure container uses the frame's true aspect ratio for portrait layout
      frame.onload = () => {
        if (frame.naturalWidth && frame.naturalHeight) {
          container.style.aspectRatio = `${frame.naturalWidth} / ${frame.naturalHeight}`;
        }
      };

      // Flip camera handler
      flipBtn.onclick = async () => {
        currentFacingMode =
          currentFacingMode === "environment" ? "user" : "environment";
        await startCamera();
      };

      // Download/Save to gallery handler
      downloadBtn.onclick = async (e) => {
        e.preventDefault();

        // Get the canvas data as blob
        canvas.toBlob(
          async (blob) => {
            // Try Web Share API first (for mobile devices)
            if (navigator.share && navigator.canShare) {
              try {
                const file = new File([blob], "navratri_photo.png", {
                  type: "image/png",
                });
                if (navigator.canShare({ files: [file] })) {
                  await navigator.share({
                    title: "Navratri Photo",
                    text: "Check out my Navratri photo!",
                    files: [file],
                  });
                  return;
                }
              } catch (err) {
                console.log("Web Share failed:", err);
                // Fall through to fallback method
              }
            }

            // Alternative method for mobile: Create a temporary link with proper MIME type
            const url = URL.createObjectURL(blob);
            const a = document.createElement("a");
            a.href = url;
            a.download = "navratri_photo.png";
            a.style.display = "none";
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);

            // Show success message
            alert("Photo saved! Check your gallery or downloads folder.");
          },
          "image/png",
          1.0
        );
      };

      // Capture logic (exports portrait with center-cropped video)
      button.onclick = () => {
        if (video.videoWidth === 0 || video.videoHeight === 0) {
          alert("Video not ready yet, try again.");
          return;
        }

        // Target size exactly matches the visible capture area (canvas) ratio
        const dpr = window.devicePixelRatio || 1;
        const rect = container.getBoundingClientRect();
        const targetWidth = Math.round(rect.width * dpr);
        const targetHeight = Math.round(rect.height * dpr);
        canvas.width = targetWidth;
        canvas.height = targetHeight;
        const ctx = canvas.getContext("2d");

        // Center-crop the video to cover the portrait canvas
        const srcW = video.videoWidth;
        const srcH = video.videoHeight;
        const targetAspect = targetWidth / targetHeight;
        const srcAspect = srcW / srcH;

        let sx = 0;
        let sy = 0;
        let sWidth = srcW;
        let sHeight = srcH;

        if (srcAspect > targetAspect) {
          // Source is wider than target -> crop width
          sWidth = Math.round(srcH * targetAspect);
          sx = Math.round((srcW - sWidth) / 2);
        } else if (srcAspect < targetAspect) {
          // Source is taller than target -> crop height
          sHeight = Math.round(srcW / targetAspect);
          sy = Math.round((srcH - sHeight) / 2);
        }

        ctx.drawImage(
          video,
          sx,
          sy,
          sWidth,
          sHeight,
          0,
          0,
          targetWidth,
          targetHeight
        );

        // Draw overlay frame to exact canvas size
        ctx.drawImage(frame, 0, 0, targetWidth, targetHeight);

        // Create image data
        const dataURL = canvas.toDataURL("image/png");

        // Show preview
        output.src = dataURL;
        output.style.display = "block";

        // Enable download and swap button positions
        downloadBtn.href = dataURL;
        downloadBtn.style.display = "inline-block";
        button.style.display = "none";

        // Send to Flask backend
        fetch("/save_photo", {
          method: "POST",
          headers: { "Content-Type": "application/x-www-form-urlencoded" },
          body: "image=" + encodeURIComponent(dataURL),
        })
          .then((res) => res.text())
          .then((msg) => console.log("Server:", msg))
          .catch((err) => console.error("Upload failed:", err));
      };
    </script>
  </body>
</html>
